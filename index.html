<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Banana Shooter - Defiende la Base</title>
    <!-- Tailwind CSS se carga desde CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Estilos personalizados para el juego, incluyendo la fuente Inter */
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;700;900&display=swap');
        body {
            font-family: 'Inter', sans-serif;
            background-color: #1a1a2e; /* Fondo oscuro */
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            padding: 10px; /* Menos padding en m√≥vil */
        }

        #game-container {
            position: relative;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            border-radius: 12px;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            align-items: center;
            max-width: 600px; 
            width: 100%;
        }

        canvas {
            background-color: #2c3e50; /* Color de fondo del juego */
            display: block;
            border: 4px solid #f39c12; /* Borde naranja llamativo */
            /* Hacer que el canvas ocupe todo el ancho disponible del contenedor */
            width: 100%; 
            height: auto; /* Mantener la proporci√≥n */
        }

        /* Estilo para la barra de vida */
        #health-bar-container {
            width: 100%;
            background-color: #333;
            border-radius: 4px;
            overflow: hidden;
            margin-bottom: 10px;
        }

        #health-bar {
            height: 15px;
            background-color: #e74c3c; /* Rojo para la vida */
            transition: width 0.3s;
        }

        /* Estilos de botones y HUD */
        .game-ui {
            padding: 10px;
            width: 100%;
            display: flex;
            justify-content: space-between;
            align-items: center;
            color: #ecf0f1;
            background-color: #111;
            border-bottom-left-radius: 8px;
            border-bottom-right-radius: 8px;
        }

        .button-control {
            background-color: #f39c12;
            color: #1a1a2e;
            padding: 12px 24px; /* Botones m√°s grandes */
            border-radius: 8px;
            font-weight: bold;
            cursor: pointer;
            transition: background-color 0.2s, transform 0.1s;
            box-shadow: 0 4px #e67e22;
            user-select: none;
            flex-grow: 1; /* Para que los botones se repartan el espacio */
            margin: 5px;
        }

        .button-control:hover {
            background-color: #e67e22;
        }

        .button-control:active {
            transform: translateY(2px);
            box-shadow: 0 2px #e67e22;
        }
        
        /* Controles espec√≠ficos para el m√≥vil (direccionales y disparo) */
        #mobile-controls {
            display: flex;
            justify-content: space-between;
            width: 100%;
            padding: 10px 0;
            background-color: #1a1a2e; /* Color oscuro para el fondo de los controles */
        }
        
        #directional-controls {
            display: flex;
            flex-direction: column;
            width: 35%; /* Ocupar menos espacio que el bot√≥n de disparo */
        }
        
        #shoot-control-container {
            width: 60%; 
        }

        /* Estilos de Power-Up y Game Over (se mantienen igual) */
        #powerup-message, #powerup-choice-screen, #game-over-screen {
            /* Asegurar que las pantallas modales se escalen correctamente con el contenedor */
            position: absolute; 
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            /* Propiedades para centrar y estilizar los modales */
            display: none; /* Por defecto est√°n ocultos */
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background-color: rgba(0, 0, 0, 0.85);
            color: white;
            padding: 20px;
            text-align: center;
            z-index: 10;
            border-radius: 12px;
        }

        #powerup-message {
            opacity: 0;
            transition: opacity 0.5s;
            font-size: 1.5rem;
            background-color: rgba(243, 156, 18, 0.9);
            color: #1a1a2e;
            height: 50px;
            padding: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 8px;
            top: 20px;
            width: 80%;
            left: 50%;
            transform: translateX(-50%);
            pointer-events: none; /* No bloquear clicks */
            position: absolute; /* Usamos position absolute para que se superponga */
        }

        /* Ajustes para el bot√≥n de disparo en m√≥vil */
        #shootButton {
            width: 100%;
            height: 100%;
            min-height: 80px; /* Altura m√≠nima para un buen objetivo t√°ctil */
            background-color: #c0392b; /* Rojo para disparar */
            box-shadow: 0 4px #a93226;
        }
        #shootButton:hover {
            background-color: #a93226;
        }
        #shootButton:active {
            transform: translateY(2px);
            box-shadow: 0 2px #a93226;
        }

        /* Ocultar controles de m√≥vil en pantallas grandes */
        @media (min-width: 768px) {
            #mobile-controls {
                display: none !important;
            }
        }
    </style>
</head>
<body>

<div id="game-container" class="max-w-xl w-full">
    <div id="health-bar-container">
        <div id="health-bar"></div>
    </div>
    <!-- Canvas de juego, tama√±o fijo para el desarrollo -->
    <canvas id="gameCanvas"></canvas>
    
    <!-- Mensaje de Power-Up de notificaci√≥n -->
    <div id="powerup-message">POWER UP OBTENIDO!</div>

    <!-- Pantalla de Elecci√≥n de Power-Up (Modal) -->
    <div id="powerup-choice-screen">
        <h2 class="text-3xl font-bold mb-4">¬°Power-Up Disponible!</h2>
        <p class="text-xl mb-4">¬øDeseas reemplazar tu Power-Up actual (<span id="current-powerup-name" class="font-bold text-yellow-400">Sin Power-Up</span>) por:</p>
        <p class="text-3xl mb-8 font-extrabold text-white" id="new-powerup-name"></p>
        
        <div class="flex space-x-4">
            <button id="acceptPowerup" class="choice-button button-control choice-accept">Aceptar</button>
            <button id="rejectPowerup" class="choice-button button-control choice-reject">Rechazar (Mantener actual)</button>
        </div>
    </div>

    <div id="game-over-screen">
        <h1 class="text-4xl font-black mb-4">¬°JUEGO TERMINADO!</h1>
        <p id="final-score" class="text-2xl mb-6">Puntuaci√≥n Final: 0</p>
        <button id="restartButton" class="button-control">Jugar de Nuevo</button>
    </div>

    <div class="game-ui">
        <span id="scoreDisplay" class="text-lg">Puntuaci√≥n: 0</span>
        <span id="powerup-display">Sin Power-Up</span>
    </div>
    
    <!-- NUEVOS CONTROLES M√ìVILES DEDICADOS -->
    <div id="mobile-controls">
        
        <!-- Botones de movimiento (Arriba/Abajo) -->
        <div id="directional-controls">
            <button id="upButton" class="button-control">‚ñ≤ Arriba</button>
            <button id="downButton" class="button-control">‚ñº Abajo</button>
        </div>

        <!-- Bot√≥n de disparo -->
        <div id="shoot-control-container">
            <button id="shootButton" class="button-control">Disparar üçå</button>
        </div>
    </div>
</div>

<!-- Bloque de Script del Juego -->
<script>
    // --- Game Logic ---
    const canvas = document.getElementById('gameCanvas');
    if (!canvas) {
        console.error("Canvas element not found.");
    }
    const ctx = canvas.getContext('2d');
    const scoreDisplay = document.getElementById('scoreDisplay');
    const healthBar = document.getElementById('health-bar');
    const gameOverScreen = document.getElementById('game-over-screen');
    const finalScoreDisplay = document.getElementById('final-score');
    const restartButton = document.getElementById('restartButton');
    
    // Referencias a los nuevos botones
    const upButton = document.getElementById('upButton');
    const downButton = document.getElementById('downButton');
    const shootButton = document.getElementById('shootButton'); 

    const powerupDisplay = document.getElementById('powerup-display');
    const powerupMessage = document.getElementById('powerup-message');
    const powerupChoiceScreen = document.getElementById('powerup-choice-screen');
    const currentPowerupName = document.getElementById('current-powerup-name');
    const newPowerupName = document.getElementById('new-powerup-name');
    const acceptPowerupButton = document.getElementById('acceptPowerup');
    const rejectPowerupButton = document.getElementById('rejectPowerup');

    
    // Canvas Dimensions
    // Mantenemos las dimensiones l√≥gicas fijas para la l√≥gica del juego.
    const GAME_WIDTH = 600;
    const GAME_HEIGHT = 400;

    // Asignar dimensiones al canvas
    canvas.width = GAME_WIDTH;
    canvas.height = GAME_HEIGHT;

    // Redimensionar el canvas visualmente al cargar (para que ocupe el ancho del contenedor)
    function resizeCanvas() {
        // La l√≥gica de CSS ya maneja el escalado visual (width: 100%),
        // pero podemos asegurar que las dimensiones l√≥gicas se respeten.
    }
    window.addEventListener('resize', resizeCanvas);
    
    // Power-Up Constants (Se mantienen)
    const BASE_SPEED = 5;
    const KILLS_TO_POWERUP = 20;

    // Game state variables (Se mantienen)
    let player = {
        x: 50,
        y: GAME_HEIGHT / 2,
        width: 30,
        height: 30,
        speed: BASE_SPEED,
        health: 125, 
        maxHealth: 125, 
        hasShield: false
    };

    let bananas = [];
    let zombies = [];
    let particles = [];
    let score = 0;
    let isGameOver = false;
    let gameRunning = false;
    let isPaused = false;
    
    // Power-Up variables
    let killsSincePowerup = 0;
    let activePowerup = null; 
    let powerupOption = null; 

    // Zombie spawn rate 
    let zombieSpawnRate = 60; 
    let frameCount = 0;

    let keys = {
        up: false,
        down: false,
        shoot: false 
    };

    // Power-Up Name Mapping (Se mantiene)
    const POWERUP_NAMES = {
        'TRIPLE': 'Triple Disparo üçåüçåüçå',
        'PIERCE': 'Perforaci√≥n üí•',
        'SPEED': 'Velocidad ‚ö°',
        'SHIELD': 'Escudo üõ°Ô∏è',
        'BIG_BANANA': 'Banana Gigante üåï'
    };


    // --- Game Classes (Models) - Se mantienen sin cambios ---

    class Banana {
        constructor(x, y, type = 'NORMAL') {
            this.x = x;
            this.y = y;
            this.velocity = 8;
            this.color = '#f1c40f';
            this.isPiercing = (type === 'PIERCE');
            this.isBig = (type === 'BIG_BANANA');

            if (this.isBig) {
                this.radius = 8;
                this.velocity = 6;
            } else {
                this.radius = 5;
                this.velocity = 8;
            }
        }

        draw() {
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2, false);
            ctx.fillStyle = this.color;
            ctx.fill();
            
            if (this.isPiercing) {
                 ctx.strokeStyle = '#c0392b';
                 ctx.lineWidth = 1;
                 ctx.stroke();
            }
            if (this.isBig) {
                 ctx.strokeStyle = '#fff';
                 ctx.lineWidth = 1;
                 ctx.stroke();
            }
        }

        update() {
            this.x += this.velocity;
        }
    }

    class Zombie {
        constructor(type = 'NORMAL') {
            this.x = GAME_WIDTH;
            this.y = Math.random() * (GAME_HEIGHT - 40) + 20;
            this.type = type;
            this.width = 20;
            this.height = 20;
            this.points = 10;
            this.maxHealth = 1;
            
            if (this.type === 'FAST') {
                this.speed = Math.random() * 1.5 + 1.2;
                this.color = '#e74c3c';
                this.points = 15;
            } else if (this.type === 'TANK') {
                this.speed = Math.random() * 0.4 + 0.2;
                this.width = 30;
                this.height = 30;
                this.color = '#34495e';
                this.maxHealth = 3;
                this.points = 30;
            } else if (this.type === 'BRUTE') {
                this.speed = Math.random() * 1 + 0.8;
                this.width = 25;
                this.height = 25;
                this.color = '#8e44ad';
                this.maxHealth = 6;
                this.points = 50;
            } else {
                this.speed = Math.random() * 0.8 + 0.5;
                this.color = '#27ae60';
            }
            
            this.currentHealth = this.maxHealth;
        }

        draw() {
            ctx.fillStyle = this.color;
            ctx.fillRect(this.x, this.y, this.width, this.height);
            
            ctx.fillStyle = (this.type === 'TANK' || this.type === 'BRUTE') ? '#f39c12' : '#c0392b';
            ctx.fillRect(this.x + 4, this.y + 4, 4, 4);
            ctx.fillRect(this.x + this.width - 8, this.y + 4, 4, 4);
            
            if (this.type === 'TANK' || this.type === 'BRUTE') {
                ctx.fillStyle = 'white';
                ctx.font = 'bold 10px Inter';
                ctx.textAlign = 'center';
                ctx.fillText(`HP: ${this.currentHealth}`, this.x + this.width / 2, this.y + this.height + 10);
            }
        }

        update() {
            this.x -= this.speed;
        }
    }

    class Particle {
        constructor(x, y, color) {
            this.x = x;
            this.y = y;
            this.radius = Math.random() * 2 + 1;
            this.color = color;
            this.velocity = {
                x: (Math.random() - 0.5) * (Math.random() * 4),
                y: (Math.random() - 0.5) * (Math.random() * 4)
            };
            this.alpha = 1;
            this.friction = 0.99;
        }

        draw() {
            ctx.save();
            ctx.globalAlpha = this.alpha;
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2, false);
            ctx.fillStyle = this.color;
            ctx.fill();
            ctx.restore();
        }

        update() {
            this.velocity.x *= this.friction;
            this.velocity.y *= this.friction;
            this.x += this.velocity.x;
            this.y += this.velocity.y;
            this.alpha -= 0.02;
        }
    }


    // --- Game Functions - Se mantienen sin cambios significativos ---
    
    function drawBase() {
        const BASE_WIDTH = 50;
        const BASE_COLOR = '#3498db';
        const ROOF_COLOR = '#e74c3c';
        const WINDOW_COLOR = '#f1c40f';

        ctx.fillStyle = BASE_COLOR;
        ctx.fillRect(0, 0, BASE_WIDTH, GAME_HEIGHT);

        ctx.fillStyle = ROOF_COLOR;
        ctx.beginPath();
        ctx.moveTo(0, 0); 
        ctx.lineTo(BASE_WIDTH, 0); 
        ctx.lineTo(BASE_WIDTH / 2, 50);
        ctx.closePath();
        ctx.fill();
        
        ctx.fillStyle = WINDOW_COLOR;
        ctx.fillRect(10, 80, 15, 15);
        ctx.fillRect(25, 120, 15, 15);
        ctx.fillRect(10, GAME_HEIGHT - 100, 15, 15);
        
        ctx.fillStyle = '#2c3e50'; 
        ctx.fillRect(20, GAME_HEIGHT - 40, 15, 40);
    }


    function initializeGame() {
        if (gameRunning) return;
        gameRunning = true;
        isPaused = false;
        
        player.health = 125; 
        player.maxHealth = 125; 
        player.y = GAME_HEIGHT / 2;
        player.speed = BASE_SPEED;
        player.hasShield = false;
        score = 0;
        isGameOver = false;
        bananas = [];
        zombies = [];
        particles = [];
        frameCount = 0;
        zombieSpawnRate = 60;
        
        killsSincePowerup = 0;
        activePowerup = null;
        powerupOption = null;
        updatePowerupDisplay();
        
        gameOverScreen.style.display = 'none';
        powerupChoiceScreen.style.display = 'none';
        updateHealthBar();
        updateScore();
        
        animate(); 
    }

    function applyPowerup(newPowerup) {
        player.speed = BASE_SPEED; 
        player.hasShield = false;
        
        activePowerup = newPowerup;

        if (activePowerup === 'SPEED') {
            player.speed = BASE_SPEED * 2;
        } else if (activePowerup === 'SHIELD') {
            player.hasShield = true;
        }
        
        killsSincePowerup = 0;
        updatePowerupDisplay();
        showPowerupMessage(POWERUP_NAMES[newPowerup]);
    }

    function grantPowerup() {
        const powerupOptions = ['TRIPLE', 'PIERCE', 'SPEED', 'SHIELD', 'BIG_BANANA'];
        
        const randomIndex = Math.floor(Math.random() * powerupOptions.length);
        powerupOption = powerupOptions[randomIndex];

        isPaused = true; 
        powerupChoiceScreen.style.display = 'flex';

        const currentName = activePowerup ? POWERUP_NAMES[activePowerup] : 'Ninguno';
        currentPowerupName.textContent = currentName;
        newPowerupName.textContent = POWERUP_NAMES[powerupOption];
        
        killsSincePowerup = 0; 
    }
    
    function showPowerupMessage(name) {
        powerupMessage.textContent = `${name} ACTIVO!`;
        powerupMessage.style.opacity = 1;
        // La animaci√≥n de desvanecimiento debe ser manejada por CSS
        // Aqu√≠ solo la ocultamos despu√©s de un tiempo
        setTimeout(() => {
            powerupMessage.style.opacity = 0;
        }, 1500);
    }

    function updatePowerupDisplay() {
        let displayText = 'Sin Power-Up';
        
        if (activePowerup) {
            displayText = POWERUP_NAMES[activePowerup];
            if (activePowerup === 'SHIELD' && player.hasShield) {
                 displayText += ' (Listo)';
            }
            powerupDisplay.classList.remove('text-ecf0f1', 'bg-transparent');
            powerupDisplay.classList.add('text-yellow-400', 'bg-yellow-400/20');
        } else {
            powerupDisplay.classList.remove('text-yellow-400', 'bg-yellow-400/20');
            powerupDisplay.classList.add('text-ecf0f1', 'bg-transparent');
        }

        if (!activePowerup || isPaused) {
            powerupDisplay.textContent = `Power-Up: ${killsSincePowerup}/${KILLS_TO_POWERUP}`;
        } else {
            powerupDisplay.textContent = displayText;
        }
    }


    function shoot() {
        const yCenter = player.y + player.height / 2;
        const xStart = player.x + player.width;
        
        let bananaType = 'NORMAL';
        if (activePowerup === 'PIERCE') bananaType = 'PIERCE';
        if (activePowerup === 'BIG_BANANA') bananaType = 'BIG_BANANA';


        bananas.push(new Banana(xStart, yCenter, bananaType));

        if (activePowerup === 'TRIPLE') {
            bananas.push(new Banana(xStart, yCenter - 10, bananaType));
            bananas.push(new Banana(xStart, yCenter + 10, bananaType));
        }
    }

    function acceptPowerup() {
        if (!powerupOption) return;
        applyPowerup(powerupOption);
        powerupOption = null;
        powerupChoiceScreen.style.display = 'none';
        isPaused = false;
        animate();
    }

    function rejectPowerup() {
        powerupOption = null;
        if (activePowerup) {
             killsSincePowerup = 0;
        }
        updatePowerupDisplay();
        powerupChoiceScreen.style.display = 'none';
        isPaused = false;
        animate();
    }


    function handleCollisions() {
        // Collisions between Bananas and Zombies
        for (let i = bananas.length - 1; i >= 0; i--) {
            const banana = bananas[i];
            let hit = false; 

            for (let j = zombies.length - 1; j >= 0; j--) {
                const zombie = zombies[j];

                if (
                    banana.x + banana.radius > zombie.x &&
                    banana.x - banana.radius < zombie.x + zombie.width &&
                    banana.y + banana.radius > zombie.y &&
                    banana.y - banana.radius < zombie.y + zombie.height
                ) {
                    zombie.currentHealth--;

                    for (let k = 0; k < 5; k++) { 
                        particles.push(new Particle(banana.x, banana.y, '#f1c40f')); 
                    }
                    
                    if (zombie.currentHealth <= 0) {
                        
                        for (let k = 0; k < 15; k++) { 
                            particles.push(new Particle(zombie.x + zombie.width / 2, zombie.y + zombie.height / 2, zombie.color));
                        }
                        
                        zombies.splice(j, 1);
                        
                        score += zombie.points; 
                        killsSincePowerup++;
                        updateScore();
                        updatePowerupDisplay();

                        if (killsSincePowerup >= KILLS_TO_POWERUP && !isPaused) {
                            grantPowerup();
                        }
                        
                    }
                    
                    hit = true;

                    if (!banana.isPiercing) {
                        break; 
                    }
                }
            }

            if ((hit && !banana.isPiercing) || banana.x > GAME_WIDTH) {
                bananas.splice(i, 1);
            }
        }

        // Collision between Zombies and Player (if the zombie reaches the left side)
        for (let i = zombies.length - 1; i >= 0; i--) {
            const zombie = zombies[i];

            if (zombie.x < player.x + player.width) {

                if (player.hasShield) {
                    player.hasShield = false;
                    updatePowerupDisplay();
                    for (let k = 0; k < 20; k++) {
                        particles.push(new Particle(player.x, player.y + player.height / 2, '#3498db'));
                    }
                    zombies.splice(i, 1); 
                    continue;
                }

                player.health -= 15; 
                updateHealthBar();
                
                zombies.splice(i, 1);

                if (player.health <= 0) {
                    player.health = 0;
                    isGameOver = true;
                    showGameOver();
                }
            }
        }
    }

    function updateHealthBar() {
        const percentage = (player.health / player.maxHealth) * 100;
        healthBar.style.width = `${percentage}%`;
        
        if (percentage < 30) {
             healthBar.style.backgroundColor = '#c0392b';
        } else if (percentage < 60) {
             healthBar.style.backgroundColor = '#e67e22';
        } else {
             healthBar.style.backgroundColor = '#2ecc71';
        }
    }

    function updateScore() {
        scoreDisplay.textContent = `Puntuaci√≥n: ${score}`;
    }
    
    function showGameOver() {
        gameRunning = false;
        gameOverScreen.style.display = 'flex';
        finalScoreDisplay.textContent = `Puntuaci√≥n Final: ${score}`;
    }


    // --- Main Game Loop ---
    function animate() {
        if (isGameOver || !gameRunning || isPaused) return; 

        ctx.clearRect(0, 0, GAME_WIDTH, GAME_HEIGHT);
        
        drawBase();

        // 2. Player Movement
        if (keys.up && player.y > 0) {
            player.y -= player.speed;
        }
        if (keys.down && player.y < GAME_HEIGHT - player.height) {
            player.y += player.speed;
        }

        // 3. Zombie Generation
        frameCount++;
        if (frameCount % Math.floor(zombieSpawnRate) === 0) {
            let zombieType = 'NORMAL';
            const random = Math.random();
            
            if (random < 0.15) {
                zombieType = 'FAST';
            } else if (random < 0.25) {
                zombieType = 'TANK';
            } else if (random < 0.30) {
                zombieType = 'BRUTE';
            }

            zombies.push(new Zombie(zombieType));
            
            if (zombieSpawnRate > 20) {
                zombieSpawnRate -= 0.1; 
            }
        }

        // 4. Update and Draw Zombies
        zombies.forEach((zombie) => {
            zombie.update();
            zombie.draw();
        });

        // 5. Update and Draw Bananas
        for (let i = bananas.length - 1; i >= 0; i--) {
            const banana = bananas[i];
            banana.update();
            banana.draw();
        }
        
        // 6. Update and Draw Particles
        for (let i = particles.length - 1; i >= 0; i--) {
            const particle = particles[i];
            particle.update();
            particle.draw();

            if (particle.alpha <= 0 || particle.radius < 0.5) {
                particles.splice(i, 1);
            }
        }

        // 7. Draw Player
        ctx.fillStyle = '#f1c40f'; 
        ctx.fillRect(player.x, player.y, player.width, player.height);
        
        if (player.hasShield) {
            ctx.strokeStyle = '#3498db';
            ctx.lineWidth = 3;
            ctx.strokeRect(player.x - 2, player.y - 2, player.width + 4, player.height + 4);
        }

        // 8. Handle Collisions
        handleCollisions();

        requestAnimationFrame(animate);
    }

    // --- Event Handlers (Actualizados para m√≥vil) ---

    // Funci√≥n auxiliar para manejar eventos de inicio (mousedown/touchstart)
    function handleStart(e, isUp) {
        if (isGameOver || isPaused) return;
        e.preventDefault();
        keys.up = isUp;
        keys.down = !isUp;
    }

    // Funci√≥n auxiliar para manejar eventos de fin (mouseup/touchend)
    function handleEnd(e) {
        // En m√≥vil, el touchend y touchcancel deben detener el movimiento
        // En desktop, el mouseup debe detenerlo
        if (e.type === 'touchend' || e.type === 'touchcancel' || e.type === 'mouseup' || e.type === 'mouseout') {
             keys.up = false;
             keys.down = false;
        }
    }

    // Eventos de rat√≥n/t√°ctiles para el bot√≥n UP
    upButton.addEventListener('mousedown', (e) => handleStart(e, true));
    upButton.addEventListener('touchstart', (e) => handleStart(e, true));
    upButton.addEventListener('mouseup', handleEnd);
    upButton.addEventListener('touchend', handleEnd);
    upButton.addEventListener('mouseout', handleEnd);

    // Eventos de rat√≥n/t√°ctiles para el bot√≥n DOWN
    downButton.addEventListener('mousedown', (e) => handleStart(e, false));
    downButton.addEventListener('touchstart', (e) => handleStart(e, false));
    downButton.addEventListener('mouseup', handleEnd);
    downButton.addEventListener('touchend', handleEnd);
    downButton.addEventListener('mouseout', handleEnd);


    // Eventos de rat√≥n/t√°ctiles para el bot√≥n SHOOT
    shootButton.addEventListener('click', () => {
        if (!isGameOver && !isPaused) {
            shoot();
        }
    });
    
    // Para evitar el "fast click" en m√≥vil
    shootButton.addEventListener('touchend', (e) => {
        e.preventDefault();
        if (!isGameOver && !isPaused) {
            shoot();
        }
    });

    // Control de Disparo con Rat√≥n (click directo en el canvas para Desktop)
    canvas.addEventListener('mousedown', (e) => {
        if (e.button === 0 && !isGameOver && !isPaused) {
            e.preventDefault();
            // Solo disparamos con el mouse en pantallas grandes, para no interferir con los botones t√°ctiles
            if (window.innerWidth > 768) { 
                shoot();
            }
        }
    });
    
    // --- Control de Teclado (Se mantiene para Desktop) ---
    document.addEventListener('keydown', (e) => {
        if (isPaused) return;
        
        if (e.key === 'w' || e.key === 'W' || e.key === 'ArrowUp') {
            keys.up = true;
        } else if (e.key === 's' || e.key === 'S' || e.key === 'ArrowDown') {
            keys.down = true;
        } else if (e.key === ' ' && !keys.shoot && !isGameOver) { 
            keys.shoot = true;
            shoot(); 
        }
    });

    document.addEventListener('keyup', (e) => {
        if (e.key === 'w' || e.key === 'W' || e.key === 'ArrowUp') {
            keys.up = false;
        } else if (e.key === 's' || e.key === 'S' || e.key === 'ArrowDown') {
            keys.down = false;
        } else if (e.key === ' ') {
            keys.shoot = false;
        }
    });

    // Power-Up modal events
    acceptPowerupButton.addEventListener('click', acceptPowerup);
    rejectPowerupButton.addEventListener('click', rejectPowerup);


    // Restart button
    restartButton.addEventListener('click', () => {
        initializeGame();
    });

    // Iniciar el juego
    window.onload = initializeGame;
</script>

</body>
</html>
